# Experiment-6

<div dir="rtl">

## بخش اول

در این بخش نیازمندی‌های گفته شده را ابتدا طبق رویکرد آزمون‌رانه شروع کردیم. برای این کار ابتدا یک تست نوشتیم که مراحل
گفته شده را انجام می‌دهد:
![test.png](Patterns/src/main/resources/images/test.png)

پس از پیاده‌سازی‌های اولیه‌ی مربوط به ساختن گراف، با استفاده از دو استراتژی گفته شده نیازمندی‌ها را پیاده‌سازی کردیم.
در نهایت نیز برای کنار هم قرار دادن این استراتژی‌ها یک کلاس کمکی `CommandRunner` اضافه کردیم که در نوشتن تابع Main و تست
ها راحت‌تر باشیم.

### الگوی State

هرگاه بخواهیم وضعیتی را نگه داشته و آن را تغییر دهیم، از الگوی State استفاده می‌کنیم.
از این الگو برای پیاده‌سازی مربوط به وضعیت جاده‌ها(یک طرفه یا دوطرفه) استفاده کردیم. در این رویکرد، هربار که state
جاده‌ها تغییر می‌کرد، نیاز داشت که گراف آپدیت کند. این موضوع دقیقا به کمک الگوی state قابل پیاده‌سازی است. بنابراین نیاز
بود تا هر state از یک کلاس abstract به صورت زیر ارثبری کند:

<div dir="ltr">

```java
public abstract class RoadState {
  public abstract void updateContext(RoadContext context);
}
```

<div dir="rtl">

به علاوه در این الگو عمدتا مفهومی به نام context نیز وجود دارد. از این مفهوم برای نگه داشتن وضعیت جاده‌ها، زمان واحد
قطار و همچنین خود گراف استفاده کرده‌ایم.

### الگوی Strategy

هرگاه بخواهیم الگوریتم‌های متفاوتی را برای یک کار یکسان استفاده کنیم، استفاده از الگوریتم استراتژی توصیه می‌شود. در این
جا برای محسابه‌ روش‌های متفاوت رسیدن به مقصد از این استراتژی استفاده کرده‌ایم. در اینجا یک رابط کلی داریم که یک تابع
برای محاسبه دارد و یک مبدا، یک مقصد و یک شهر مورد تنفر می‌گیرد:

<div dir="ltr">

```java
public interface ITravelStrategy {
  Integer calculate(Integer src, Integer dst, Integer hated);
}
```

<div dir="rtl">

با در دست داشتن اینها الگوریتم باید بتواند محاسبات خودش را انجام دهد. بدین ترتیب، هر کدام از روش‌ه‌های ما یعنی قطار و
اتوبوس از این رابط extend می‌کنند و با داشتن context محاسبات خود را که همان bfs و Dijkstra هست انجام می‌دهند.
## بخش دوم

- دو مورد اعمال الگوی Facade: برای کلاس‌های CodeGenerator و Parser، دو کلاس Facade ساخته شد تا اولا پیجیدگی داخل این دو
  کلاس را پنهان کند و دوما یک رابط ساده برای کلاس‌هایی که میخواهند با آن‌ها کار کنند ارايه کند
- یک مورد State/Strategy یا استفاده از Polymorphism به جای شرط:
  در کلاس SymbolType یک پارامتر به Enum ها اضافه شد که VarType مربوط به هر مورد را ذخیره می‌کرد، و همین امر باعث شد که
  شرط‌های switch مختلف از بین بروند و تنها گرفتن مقدار varType انجام شود.
- یک مورد Separate Query From Modifier:
  برای این مورد در کلاس Memory، به جای توابع get قبلی، دو تابع جدید نوشته شده اند، که یکی وظیفه‌اش تنها get کردن و دیگری
  increment کردن است.
  نام توابع incrementTemp و incrementDataAddress است (دو مورد دیگر همان اسم قبلی را دارند.)
- یک مورد Self Encapsulated Field: در کلاس‌های Address، Parser و Rule این مورد انجام شده است (setter و getter)
- دو مورد مختلف غیر از بازآرایی‌های مطرح‌شده در موارد بالا: دو مورد تابع extract شده اند (doShiftAction و doReduceAction).
و مورد دوم اینکه مقدار scanner در کلاس Main استخراج شده و در یک متغیر قرار گرفته است.

## بخش سوم

</div>